A practical milestone plan
• Phase 1 (now)
   • Refactor to MorphologyEngine(language:), NLTokenizer integration, per‑language rules containers, language‑scoped overrides, and feature‑gating API.
   • Keep English feature parity; ensure all public APIs accept/return data types that won’t need to change for Spanish (and friends).
• Phase 2
   • Add POS/lemma hints via NLTagger for English first. Define the protocol that lets per‑language modules opt‑in to POS hints if available for that locale.
   • Build the test harness: Swift Testing suites and accuracy metrics for English.
• Phase 3
   • Implement Spanish module (rules + data files). Start with: pluralization, articles (el/la/un/una), basic verb conjugations you will expose in the UI, adjective order/agreement constraints, and negation.
   • Copy the English test harness and adapt the corpus to Spanish. Set the same ≥95% accuracy target on an AAC‑relevant list.
   • Update the UI gating so only relevant transforms are shown when the app language or the tile’s language is Spanish.
• Phase 4
   • Add more languages as needed, each following the same pattern: rules module, data files, tests, UI gating.

Integration tips for your current app
• You already store per‑tile languageCode on Tile and allow language selection in TileEditorView. Use that to instantiate the engine with the right language for tile‑specific transforms, and default to app language for sentence‑level transforms in SentenceBarView.
• Speaker already supports languageOverride; keep morphology and TTS aligned: when you transform text using a per‑tile language, pass the same language to Speaker for previews or playback.
• Maintain a clean fallback: if a transform isn’t supported in the current language, gracefully return the original text and (optionally) present alternative actions.
